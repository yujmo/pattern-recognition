import fun
import random

#-*- coding: utf-8 -*-

"""
算法描述：K-means(C-means)：
    1. 选取K个初始聚类中心，Z1(1),Z2(1),...Zk(k)
        ×：括号内的序号为寻找聚类中心的迭代运算的次序号
        ×：聚类中心的向量值任意设定
    2. 逐个将需分类的模式样本{x}按最小距离准则分给K个聚类中心的一个
    3. 计算各个聚类中心的新的向量值，Zj(k+1)，求各聚类域中所包含样本的均值向量，以均值向量作为
        新的中点，再返回第二步，直到前后两次的聚类中心的向量值相等
"""

#定义数据集
X = Y =  {'X1':(0,0),'X2':(1,0),'X3':(0,1),'X4':(1,1),'X5':(2,1),'X6':(1,2),'X7':(2,2),'X8':(3,2),'X9':(6,6),'X10':(7,6),'X11':(8,6),'X12':(6,7),'X13':(7,7),'X14':(8,7),'X15':(9,7),'X16':(7,8),'X17':(8,8),'X18':(9,8),'X19':(8,9),'X20':(9,9)}

if __name__ == "__main__":
    #设置初始值
    Y = iter(X)
    Z1,Z2,Z,tmp=(1,0),(8,7),[[],[]],next(Y,0)
    while tmp:
        if fun.getMinlength(X[tmp],Z1,Z2): Z[0].append(tmp)
        else: Z[1].append(tmp)
        tmp = next(Y,0)




